# 反射

1. 使用类对象创建

   ```java
   Foo foo1 = new Foo();
   Class c1 = Foo.class;
   ```

2. 使用对象的方式

   ```Java
   Foo foo1 = new Foo();
   Class c2 = foo1.getClass();
   ```

3. 使用路径的方式

   ```java
   Class c3 = null;
   try{
     c3 = Class.forName("反射.Foo");//会抛出异常
   }catch(Exception e){
     e.printStackTrace();
   }
   ```

   ### 实例化对象

   ```java
   try{
     Foo foo =(Foo) c1.newInstance()
   }catch(Exception e){
     e.printStackTrace();
   }
   ```

   <br/>

   <br/>

   ### 动态加载类

   $$
   静态类是在编译的时候，需要加载，如果没有类就会报错。动态类就可以解决这个问题。在编译的时候保证不会报错
   $$



```java
//首先在创建一个接口用来
//这个是OfficeAble.java
interface OfficeAble {
    public void start();
}
class Word implements OfficeAble{
    public void start(){
        System.out.println("打印word");
    }
}
class Excel implements  OfficeAble{
    public void start() {
        System.out.println("打印Excel");
    }
} 
  
  public class OfferBetter {
    public static void main(String[] args) {
        try {
            //在运行时候加载。而不是编译时候加载。
            Class c = Class.forName(args[0]);//这里的args[0]为反射.Word
//                Word w = (Word)c.newInstance();
//                w.start();
            OfficeAble oa = (OfficeAble)c.newInstance();
            oa.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## 举个例子：

```java
public class ClassDemo3 {
    public static void main(String[] args) {
        printClassMessage(new Word());//这个是之前创建好的类
        System.out.println("********************");
        printClassMessage("roofxixi");//这个是拿到String的信息
    }
    public static void printClassMessage(Object obj){
        //要获取类的信息，首先要获得类的类类型
        Class c = obj.getClass();//传递的是那个子类的对象，c就是该子类的类类型
        //获取类的名称
        System.out.println("类的名称是:"+c.getName());
        //Method类，方法对象，一个成员
        // 就是一个Method对象
        Method[] ms = c.getMethods();//这个是包括自己的继承来的类方法
        c.getDeclaredMethods();//这个是自己的方法
        for(Method m:ms){
            System.out.println("方法返回值的类型:"+m.getReturnType());
            System.out.println("方法的名称："+m.getName());
            Class[] param =  m.getParameterTypes();//传入参数的类类型。
            for(Class c1:param){
                System.out.println("传入参数的类型名称:"+c1.getName());
            }
            System.out.println("===============");
        }
    }
}
```

<br/>

## 获取成员变量

**成员变量也是对象，java.lang.reflect.Field封装了关于成员变量的操作。**

```java
Object obj;
Field[] fs = c.getFields();
Field[] fs = c.getDeclaredFields();//这是自己写的成员变量
        for (Field field:fs){
            //得到成员变量的类型的类类型
            Class fileType = field.getType();
            String typeName = fileType.getName();
            System.out.println("成员变量的信息："+typeName+"+"+field.getName());
        }
```



## 获取构造方法

**封装在java.lang.reflect.Constructor类中**

```Java
Constructor[] cs = c.getConstructors();//获得共有的构造方法
Constructor[] cs = c.getDeclaredConstructors();//获得自己写的构造方法
for(Constructor constructor:cs){
            System.out.println("构造方法的名字："+constructor.getName());
            Class[] classes = constructor.getParameterTypes();//获得构造函数参数类类型
            for(Class cc:classes){
                System.out.println("构造函数中参数的值类型:"+cc.getName());
            }
        }
```

<br/>

## 方法的反射

1. 如何获取某个方法：方法的名称和方法的参数列表才能唯一决定某个方法
2. 方法反射的操作: method.invoke(对象，参数列表)

```java
//获取一个方法，1.获取类的方法首先要获得方法
 Class<A> a = A.class;
 //2.获取方法名称和参数列表来决定，getMethod获得public方法
 Method m =  a.getDeclaredMethod("print",new Class[]{int.class,int.class});
 //方法的反射操作,前面是对象，后面是参数，绑定对象与参数的连接。
 m.invoke(new A(),1,2);
```

<br/>

## 范型的本质

**实在编译时检测，假如跳过就没有用了。**